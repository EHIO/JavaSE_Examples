**设计模式**： 经验的总结。

    分类方式一:
    A:创建型   创建对象
        社会化的分工越来越细，自然在软件设计方面也是如此，
        因此对象的创建和对象的使用分开也就成为了必然趋势。
        因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，
        从而能够高效地创建对象就是创建型模式要探讨的问题。
    B:结构型   对象的组合
        在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，
        因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。
        对象结构的设计很容易体现出设计人员水平的高低
    C:行为型   类或对象怎样进行交互和职责分配
        在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，
        如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高
    分类方式二:根据处理的是类还是对象，分为类模式和对象模式
    类模式
    对象模式
        
**创建型模式(creational)(5个)**

     单例模式(Singleton)：(独一无二的对象)保证一个类只有一个实例，并提供一个访问它的全局访问点
     -- 确保有且只有一个对象被创建
     抽象工厂(Abstract Factory)：提供一个接口， 用于创建相关或依赖对象的家族， 而不需要明确指定具体类。
     -- 允许客户创建对象的家庭， 而无需指定它们的具体类
     工厂方法(Factory Method)：定义了一个创建对象的接口， 但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
     -- 由子类决定要创建的具体类是哪一个
     建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。
     原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。

**结构型(structural)(7个)**

    装饰者模式(Decorator)：动态的将责任附加到对象上， 想要扩展功能， 装饰者提供了有别于继承的另一种选择
    -- 包装一个对象， 以提供新的行为
    适配器模式(Adapter)：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
    -- 转换接口
    外观模式(Facade)：提供了一个统一的接口， 用来访问子系统的一群接口。 外观定义了一个高层接口， 让子系统更容易使用
    -- 简化接口
    组合模式(Composite)：将对象组成树形结构来表示“整体/部分”的层次关系，组合能让用户以一致性和方式处理个别对象和对象组合
    -- 客户用一致性的方式处理对象集合和单个对象
    代理模式(Proxy)：为另一个对象提供一个替身或点位符以控制对这个对象的访问。
    -- 包装对象， 以控制对此对象的访问
    桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。
    享元模式(Flyweight)：使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；
        它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。
        常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。于接口不兼容而不能一起工作那些类可以一起工作。

**行为型(behavior)(11个)**

    策略模式(Strategy)：定义了算法族， 分别封装起来， 让它们之间可以相互替换。 此模式让算法的变化独立于使用此算法的客户。
    —— 封装可以互换的行为， 并使用委托来决定使用哪一个行为
    观察者模式(Observer)：定义了对象间一对多的依赖关系，这样一来， 当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
    —— 让对象能够在状态改变时被通知
    模板方法(Template Method)：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
    -- 由子类决定如何实现算法中的步骤
    命令模式(Command)：将"请求"封装成对象， 以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作
    -- 封装请求成为对象
    迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
    -- 在对象的集合之中游走， 而不暴露集合的实现
    状态模式(State)：允许对象在内部状态改变时改变它的行为。对象看起来好像改变了它的类。
    -- 封装基于状态的行为，并使用委托在行为之间切换
    职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
    中介者模式(Mediator) ：用一个中介对象封装一些列的对象交互。
    访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。
    解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
 
**类模式**

    模板方法模式(Template Method)、
    适配器模式(Adapter)、
    工厂方法模式(Factory Method)、
    解释器模式(Interpreter)
**对象模式**

    抽象工厂模式(Abstract Factory)，
    建造者模式(Builder)，
    原型模式(Prototype)，
    单例模式(Singleton) 
    外观模式(Facade)、
    代理模式(Proxy)、
    装饰模式(Decorator)、
    桥接模式(Bridge)、
    组合模式(Composite)、
    享元模式(Flyweight)、
    观察者模式(Observer)、 
    状态模式(State)、
    命令模式(Command)、
    访问者模式(Visitor)、
    策略模式(Strategy)、
    备忘录模式(Memento)、
    责任链模式(Chain of Responsibility)、
    迭代器模式(Iterator)、
    中介者模式(调停者模式)(Mediator)
     
     
     
     
封装变化
多用组合， 少用继承
针对接口编程， 不针对实现编程
为交互对象之间的松耦合设计而努力
依赖抽象， 不要依赖具体类
对拓展开放， 对修改关闭
依赖抽象， 不要依赖具体类
只和朋友交谈
别找我， 我会找你
类应该只有一个被改变的理由