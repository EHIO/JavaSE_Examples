**设计模式**： 经验的总结。
    分类方式一:
    A:创建型   创建对象
        社会化的分工越来越细，自然在软件设计方面也是如此，
        因此对象的创建和对象的使用分开也就成为了必然趋势。
        因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，
        从而能够高效地创建对象就是创建型模式要探讨的问题。
    B:结构型   对象的组合
        在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，
        因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。
        对象结构的设计很容易体现出设计人员水平的高低
    C:行为型   类或对象怎样进行交互和职责分配
        在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，
        如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高
    分类方式二:根据处理的是类还是对象，分为类模式和对象模式
    类模式
    对象模式
        
**创建型模式(creational)(5个)**

     单例模式(Singleton)：(独一无二的对象)保证一个类只有一个实例，并提供一个访问它的全局访问点
     抽象工厂(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。
     工厂方法(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。
     建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。
     原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。

**结构型(structural)(7个)**

    装饰模式(Decorator)：动态的将责任附加到对象上， 想要扩展功能， 装饰者提供了有别于继承的另一种选择
    -- 包装一个对象， 以提供新的行为
    适配器模式(Adapter)：将一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
    外观模式(Facade)：提供了一个统一的接口， 用来访问子系统的一群接口。 外观定义了一个高层接口， 让子系统更容易使用
    组合模式(Composite)：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。
    代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问。
    桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。
    享元模式(Flyweight)：使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；
        它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。
        常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。于接口不兼容而不能一起工作那些类可以一起工作。

**行为型(behavior)(11个)**

    策略模式(Strategy)：定义了算法族， 分别封装起来， 让它们之间可以相互替换。 此模式让算法的变化独立于使用此算法的客户。
    —— 封装可以互换的行为， 并使用委托来决定使用哪一个
    观察者模式(Observer)：定义了对象间一对多的依赖关系，这样一来， 当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
    —— 让对象能够在状态改变时被通知
    迭代器模式(Iterator)：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。
    模板方法(Template Method)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。
    命令模式(Command)：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。
    状态模式(State)：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。
    职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
    中介者模式(Mediator) ：用一个中介对象封装一些列的对象交互。
    访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。
    解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
 
**类模式**
    模板方法模式(Template Method)、
    适配器模式(Adapter)、
    工厂方法模式(Factory Method)、
    解释器模式(Interpreter)
**对象模式**
    抽象工厂模式(Abstract Factory)，
    建造者模式(Builder)，
    原型模式(Prototype)，
    单例模式(Singleton) 
    外观模式(Facade)、
    代理模式(Proxy)、
    装饰模式(Decorator)、
    桥接模式(Bridge)、
    组合模式(Composite)、
    享元模式(Flyweight)、
    观察者模式(Observer)、 
    状态模式(State)、
    命令模式(Command)、
    访问者模式(Visitor)、
    策略模式(Strategy)、
    备忘录模式(Memento)、
    责任链模式(Chain of Responsibility)、
    迭代器模式(Iterator)、
    中介者模式(调停者模式)(Mediator) 